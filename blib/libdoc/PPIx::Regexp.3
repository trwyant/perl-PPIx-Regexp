.\" Automatically generated by Pod::Man 2.22 (Pod::Simple 3.08)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "PPIx::Regexp 3"
.TH PPIx::Regexp 3 "2009-10-15" "perl v5.10.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
PPIx::Regexp \- Represent a regular expression of some sort
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 5
\& use PPIx::Regexp;
\& use PPIx::Regexp::Dumper;
\& my $re = PPIx::Regexp\->new( \*(Aqqr{foo}smx\*(Aq );
\& PPIx::Regexp::Dumper\->new( $re )
\&     \->print();
.Ve
.SH "INHERITANCE"
.IX Header "INHERITANCE"
.Vb 2
\& PPIx::Regexp
\& isa PPIx::Regexp::Node
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
The purpose of the \fIPPIx-Regexp\fR package is to parse regular
expressions in a manner similar to the way the \s-1PPI\s0 package parses
Perl. This class forms the root of the parse tree, playing a role
similar to PPI::Document.
.PP
Navigation is similar to that provided by \s-1PPI\s0. That is to say,
things like \f(CW\*(C`children\*(C'\fR, \f(CW\*(C`find_first\*(C'\fR, \f(CW\*(C`snext_sibling\*(C'\fR and so on all
work pretty much the same way as in \s-1PPI\s0.
.PP
The class hierarchy is also similar to \s-1PPI\s0. Except for some
utility classes (the dumper, the lexer, and the tokenizer) all classes
are descended from PPIx::Regexp::Element, which
provides basic navigation. Tokens are descended from
PPIx::Regexp::Token, which provides content. All
containers are descended from PPIx::Regexp::Node,
which provides for children, and all structure elements are descended
from PPIx::Regexp::Structure, which provides beginning and ending
delimiters, and a type.
.PP
There are two features of \s-1PPI\s0 that this package does not provide
\&\- mutability and operator overloading. There are no plans for serious
mutability, though something like \s-1PPI\s0's \f(CW\*(C`prune\*(C'\fR functionality
might be considered. Similarly there are no plans for operator
overloading, which appears to the author to represent a performance hit
for little tangible gain.
.SH "METHODS"
.IX Header "METHODS"
This class provides the following public methods. Methods not documented
here are private, and unsupported in the sense that the author reserves
the right to change or remove them without notice.
.SS "new"
.IX Subsection "new"
.Vb 1
\& my $re = PPIx::Regexp\->new(\*(Aq/foo/\*(Aq);
.Ve
.PP
This method instantiates a \f(CW\*(C`PPIx::Regexp\*(C'\fR object from a string, a
PPI::Token::QuoteLike::Regexp, a
PPI::Token::Regexp::Match, or a
PPI::Token::Regexp::Substitute.
Honestly, any PPI::Element will do, but only the three
Regexp classes mentioned previously are likely to do anything useful.
.SS "new_from_cache"
.IX Subsection "new_from_cache"
This static method wraps \*(L"new\*(R" in a caching mechanism. Only one object
will be generated for a given PPI::Element, no matter
how many times this method is called. Calls after the first for a given
PPI::Element simply return the same \f(CW\*(C`PPIx::Regexp\*(C'\fR object.
.PP
When the \f(CW\*(C`PPIx::Regexp\*(C'\fR object is returned from cache, the values of
the optional arguments are ignored.
.PP
Calls to this method with the regular expression in a string rather than
a PPI::Element will not be cached.
.SS "flush_cache"
.IX Subsection "flush_cache"
.Vb 2
\& $re\->flush_cache();            # Remove $re from cache
\& PPIx::Regexp\->flush_cache();   # Empty the cache
.Ve
.PP
This method flushes the cache used by \*(L"new_from_cache\*(R". If called as a
static method with no arguments, the entire cache is emptied. Otherwise
any objects specified are removed from the cache.
.SS "capture_names"
.IX Subsection "capture_names"
.Vb 3
\& foreach my $name ( $re\->capture_names() ) {
\&     print "Capture name \*(Aq$name\*(Aq\en";
\& }
.Ve
.PP
This method returns the capture names found in the regular expression.
.SS "errstr"
.IX Subsection "errstr"
This static method returns the error string from the most recent attempt
to instantiate a \f(CW\*(C`PPIx::Regexp\*(C'\fR. It will be \f(CW\*(C`undef\*(C'\fR if the most recent
attempt succeeded.
.SS "failures"
.IX Subsection "failures"
.Vb 1
\& print "There were ", $re\->failures(), " parse failures\en";
.Ve
.PP
This method returns the number of parse failures. This is a count of the
number of unknown tokens plus the number of unterminated structures plus
the number of unmatched right brackets of any sort.
.SS "max_capture_number"
.IX Subsection "max_capture_number"
.Vb 2
\& print "Highest used capture number ",
\&     $re\->max_capture_number(), "\en";
.Ve
.PP
This method returns the highest capture number used by the regular
expression. If there are no captures, the return will be 0.
.SS "modifier"
.IX Subsection "modifier"
.Vb 3
\& my $re = PPIx::Regexp\->new( \*(Aqs/(foo)/${1}bar/smx\*(Aq );
\& print $re\->modifier()\->content(), "\en";
\& # prints \*(Aqsmx\*(Aq.
.Ve
.PP
This method retrieves the modifier of the object. This comes from the
end of the initializing string or object.
.SS "regular_expression"
.IX Subsection "regular_expression"
.Vb 3
\& my $re = PPIx::Regexp\->new( \*(Aqs/(foo)/${1}bar/smx\*(Aq );
\& print $re\->regular_expression()\->content(), "\en";
\& # prints \*(Aq/(foo)/\*(Aq.
.Ve
.PP
This method returns that portion of the object which actually represents
a regular expression.
.SS "replacement"
.IX Subsection "replacement"
.Vb 3
\& my $re = PPIx::Regexp\->new( \*(Aqs/(foo)/${1}bar/smx\*(Aq );
\& print $re\->replacement()\->content(), "\en";
\& # prints \*(Aq${1}bar/\*(Aq.
.Ve
.PP
This method returns that portion of the object which represents the
replacement string. This will be \f(CW\*(C`undef\*(C'\fR unless the regular expression
actually has a replacement string. Delimiters will be included, but
there will be no beginning delimiter unless the regular expression was
bracketed.
.SS "source"
.IX Subsection "source"
.Vb 1
\& my $source = $re\->source();
.Ve
.PP
This method returns the object or string that was used to instantiate
the object.
.SS "type"
.IX Subsection "type"
.Vb 3
\& my $re = PPIx::Regexp\->new( \*(Aqs/(foo)/${1}bar/smx\*(Aq );
\& print $re\->type()\->content(), "\en";
\& # prints \*(Aqs\*(Aq.
.Ve
.PP
This method retrieves the type of the object. This comes from the
beginning of the initializing string or object, and will be one of 's',
\&'m', 'qr', or ''.
.SH "RESTRICTIONS"
.IX Header "RESTRICTIONS"
By the nature of this module, it is never going to get everything right.
The known problem areas involve interpolations one way or another.
.SS "Ambiguous Syntax"
.IX Subsection "Ambiguous Syntax"
Perl's regular expressions contain cases where the syntax is ambiguous.
A particularly egregious example is an interpolation followed by square
or curly brackets, for example \f(CW$foo[...]\fR. There is nothing in the
syntax to say whether the programmer wanted to interpolate an element of
array \f(CW@foo\fR, or whether he wanted to interpolate scalar \f(CW$foo\fR, and
then follow that interpolation by a character class.
.PP
The \fIperlop\fR documentation notes that in this case what Perl does is to
guess. That is, it employs various heuristics on the code to try to
figure out what the programmer wanted. These heuristics are documented
as being undocumented (!) and subject to change without notice.
.PP
Given this situation, this module's chances of duplicating every Perl
version's interpretation of every regular expression is pretty much nil.
What it does now is to assume that square brackets containing \fBonly\fR an
integer or an interpolation represent a subscript; otherwise they
represent a character class. Similarly, curly brackets containing
\&\fBonly\fR a bareword or an interpolation are a subscript; otherwise they
represent a quantifier.
.SS "Static Parsing"
.IX Subsection "Static Parsing"
It is well known that Perl can not be statically parsed. That is, you
can not completely parse a piece of Perl code without executing that
same code.
.PP
Nevertheless, this class is trying to statically parse regular
expressions. The main problem with this is that there is no way to know
what is being interpolated into the regular expression by an
interpolated variable. This is a problem because the interpolated value
can change the interpretation of adjacent elements.
.PP
This module deals with this by making assumptions about what is in an
interpolated variable. These assumptions will not be enumerated here,
but in general the principal is to assume the interpolated value does
not change the interpretation of the regular expression. For example,
.PP
.Vb 2
\& my $foo = \*(Aqa\-z]\*(Aq;
\& my $re = qr{[$foo};
.Ve
.PP
is fine with the Perl interpreter, but will confuse the dickens out of
this module. Similarly and more usefully, something like
.PP
.Vb 2
\& my $mods = \*(Aqi\*(Aq;
\& my $re = qr{(?$mods:foo)};
.Ve
.PP
or maybe
.PP
.Vb 2
\& my $mods = \*(Aqi\*(Aq;
\& my $re = qr{(?$mods)$foo};
.Ve
.PP
probably sets a modifier of some sort, and that is how this module
interprets it. If the interpolation is \fBnot\fR about modifiers, this
module will get it wrong. Another such semi-benign example is
.PP
.Vb 2
\& my $foo = $] >= 5.010 ? \*(Aq?<foo>\*(Aq : \*(Aq\*(Aq;
\& my $re = qr{($foo\ew+)};
.Ve
.PP
which will parse, but this module will never realize that it might be
looking at a named capture.
.SS "Non-Standard Syntax"
.IX Subsection "Non-Standard Syntax"
There are modules out there that alter the syntax of Perl. If the syntax
of a regular expression is altered, this module has no way to understand
that it has been altered, much less to adapt to the alteration. The
following modules are known to cause problems:
.PP
Acme::PerlML, which renders Perl as \s-1XML\s0.
.PP
Data::PostfixDeref, which causes Perl to interpret
suffixed empty brackets as dereferencing the thing they suffix.
.PP
Filter::Trigraph, which recognizes \s-1ANSI\s0 C trigraphs,
allowing Perl to be written in the \s-1ISO\s0 646 character set.
.PP
Perl6::Pugs. Enough said.
.PP
Perl6::Rules, which back-ports some of the Perl 6
regular expression syntax to Perl 5.
.PP
Regexp::Extended, which extends regular expressions
in various ways, some of which seem to conflict with Perl 5.010.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Regexp::Parser, which parses a bare regular expression
(without enclosing \f(CW\*(C`qr{}\*(C'\fR, \f(CW\*(C`m//\*(C'\fR, or whatever) and uses a different
navigation model.
.SH "SUPPORT"
.IX Header "SUPPORT"
Support is by the author. Please file bug reports at
<http://rt.cpan.org>, or in electronic mail to the author.
.SH "AUTHOR"
.IX Header "AUTHOR"
Thomas R. Wyant, \s-1III\s0 \fIwyant at cpan dot org\fR
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright 2009 by Thomas R. Wyant, \s-1III\s0.
